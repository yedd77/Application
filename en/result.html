<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <script src="../script.js"></script>
    <title>NeuroSort</title>
</head>

<body>
    <div id="error" class="error" style="display: none;">
        <h2>Error</h2>
        <p>No detection data found. Please go back and scan an image.</p>
        <button class="error-button" onclick="goBack()">Go Back</button>
    </div>

    <div id="result" style="display: none;">
        <div class="result-wrapper">
            <div class="background-layer">
                <img id="backgroundImage" class="background-image" alt="">
            </div>

            <div class="result-container">
                <div class="image-wrapper">
                    <img id="resultImage" class="result-image" alt="Detection Result">
                    <div id="boundingBoxes" class="bounding-boxes"></div>
                </div>
            </div>
            <button class="next-button" onclick="goToNextPage()">Next</button>
        </div>
    </div>
</body>
<script>
    // Define everything at the top
    const DETECTION_COLORS = {
        'paper': '#237db2',
        'plastic': '#e4861b',
        'metal': '#99612d',
        'glass': '#99612d'
    };

    // Function to get color based on detection name
    function getDetectionColor(prediction) {
        const name = prediction.name.toLowerCase();
        console.log("Detection name:", prediction.name, "→ lowercase:", name, "→ color:", DETECTION_COLORS[name]);
        return DETECTION_COLORS[name] || '#00ff00';
    }

    // Function to get the prediction with the highest confidence
    function getHighestConfidencePrediction(predictions) {
        if (!predictions || predictions.length === 0) return null;

        // Sort by confidence descending and return the first (highest)
        const sortedPredictions = predictions.sort((a, b) => b.confidence - a.confidence);
        console.log("All predictions:", predictions);
        console.log("Highest confidence prediction:", sortedPredictions[0]);
        return sortedPredictions[0];
    }

    // Load image and predictions from storage
    function loadResults() {
        try {
            const imageData = sessionStorage.getItem("uploadedImage");
            const predictionData = localStorage.getItem("prediction");

            if (!imageData || !predictionData) {
                showError();
                return;
            }

            const predictions = JSON.parse(predictionData);
            console.log("Loaded predictions:", predictions);
            setupImageAndDetections(imageData, predictions);

        } catch (error) {
            console.error("Error loading results:", error);
            showError();
        }
    }

    // Setup image and draw bounding boxes
    function setupImageAndDetections(imageData, predictions) {
        const resultImage = document.getElementById('resultImage');
        const backgroundImage = document.getElementById('backgroundImage');
        const boundingBoxesContainer = document.getElementById('boundingBoxes');

        backgroundImage.src = imageData;

        resultImage.onload = function () {
            console.log("Main image loaded");
            document.getElementById('result').style.display = 'block';

            // Wait for the image to be fully rendered before calculating positions
            setTimeout(() => {
                drawBoundingBox(resultImage, boundingBoxesContainer, predictions);
            }, 100);
        };

        resultImage.onerror = function () {
            console.error("Failed to load main image");
            showError();
        };

        resultImage.src = imageData;
    }

    // Fixed bounding box drawing function
    function drawBoundingBox(imageElement, container, predictions) {
        container.innerHTML = '';

        // Get only the highest confidence prediction
        const bestPrediction = getHighestConfidencePrediction(predictions);
        if (!bestPrediction) {
            console.log("No valid predictions found");
            return;
        }

        // Get the container's position and dimensions
        const containerRect = container.getBoundingClientRect();
        const imageRect = imageElement.getBoundingClientRect();
        
        // Get image natural dimensions
        const naturalWidth = imageElement.naturalWidth;
        const naturalHeight = imageElement.naturalHeight;
        
        // Get displayed image dimensions
        const displayedWidth = imageRect.width;
        const displayedHeight = imageRect.height;

        // Calculate scaling factors
        const scaleX = displayedWidth / naturalWidth;
        const scaleY = displayedHeight / naturalHeight;

        // Calculate image position relative to the container
        const imageOffsetX = imageRect.left - containerRect.left;
        const imageOffsetY = imageRect.top - containerRect.top;

        console.log("Fixed positioning calculations:", {
            container: { width: containerRect.width, height: containerRect.height },
            image: {
                natural: { width: naturalWidth, height: naturalHeight },
                displayed: { width: displayedWidth, height: displayedHeight },
                offset: { x: imageOffsetX, y: imageOffsetY }
            },
            scale: { x: scaleX, y: scaleY }
        });

        // Draw only the best prediction
        const box = bestPrediction.box;
        if (!box) {
            console.log("No bounding box data found");
            return;
        }

        // Calculate scaled coordinates relative to the container
        const scaledX1 = (box.x1 * scaleX) + imageOffsetX;
        const scaledY1 = (box.y1 * scaleY) + imageOffsetY;
        const scaledX2 = (box.x2 * scaleX) + imageOffsetX;
        const scaledY2 = (box.y2 * scaleY) + imageOffsetY;

        const boxWidth = scaledX2 - scaledX1;
        const boxHeight = scaledY2 - scaledY1;

        // Validate box dimensions
        if (boxWidth <= 0 || boxHeight <= 0) {
            console.warn("Invalid box dimensions:", { width: boxWidth, height: boxHeight });
            return;
        }

        const boundingBox = document.createElement('div');
        boundingBox.className = 'bounding-box';

        // Get color for this detection
        const color = getDetectionColor(bestPrediction);
        boundingBox.style.borderColor = color;
        boundingBox.style.backgroundColor = color + '26';
        boundingBox.style.boxShadow = `0 0 15px ${color}99`;
        boundingBox.style.position = 'absolute';
        boundingBox.style.border = '2px solid';
        boundingBox.style.borderRadius = '4px';
        boundingBox.style.pointerEvents = 'none';

        // Set position and dimensions
        boundingBox.style.left = scaledX1 + 'px';
        boundingBox.style.top = scaledY1 + 'px';
        boundingBox.style.width = boxWidth + 'px';
        boundingBox.style.height = boxHeight + 'px';

        // Create main label
        const label = document.createElement('div');
        label.className = 'box-label';
        label.style.backgroundColor = color + 'F2';
        label.style.borderColor = color;
        label.style.position = 'absolute';
        label.style.padding = '4px 8px';
        label.style.borderRadius = '4px';
        label.style.fontSize = '12px';
        label.style.fontWeight = 'bold';
        label.style.color = 'white';
        label.style.whiteSpace = 'nowrap';
        label.style.border = '1px solid';

        const confidence = Math.round(bestPrediction.confidence * 100);
        label.textContent = `${bestPrediction.name} (${confidence}%)`;

        // Position label (above or below box based on available space)
        if (scaledY1 > 40) {
            label.style.top = '-35px';
            label.style.left = '0px';
        } else {
            label.style.top = boxHeight + 5 + 'px';
            label.style.left = '0px';
            label.classList.add('label-below');
        }

        // Create recyclable label
        const recyclableLabel = document.createElement('div');
        recyclableLabel.className = 'recyclable-label';
        recyclableLabel.style.position = 'absolute';
        recyclableLabel.style.padding = '2px 6px';
        recyclableLabel.style.backgroundColor = '#28a745';
        recyclableLabel.style.color = 'white';
        recyclableLabel.style.fontSize = '10px';
        recyclableLabel.style.borderRadius = '3px';
        recyclableLabel.style.fontWeight = 'bold';
        recyclableLabel.style.whiteSpace = 'nowrap';
        recyclableLabel.textContent = 'Recyclable';

        // Position recyclable label below the main label
        if (scaledY1 > 40) {
            recyclableLabel.style.top = '-15px';
            recyclableLabel.style.left = '0px';
        } else {
            recyclableLabel.style.top = boxHeight + 25 + 'px';
            recyclableLabel.style.left = '0px';
        }

        // Add both labels to bounding box
        boundingBox.appendChild(label);
        boundingBox.appendChild(recyclableLabel);
        container.appendChild(boundingBox);

        console.log("Bounding box created:", {
            prediction: bestPrediction,
            originalBox: box,
            scaledPosition: { x1: scaledX1, y1: scaledY1, x2: scaledX2, y2: scaledY2 },
            dimensions: { width: boxWidth, height: boxHeight },
            confidence: confidence
        });
    }

    // Show error message
    function showError() {
        document.getElementById('error').style.display = 'flex';
    }

    // Navigation to previous page
    function goBack() {
        window.history.back();
    }

    // Navigation to next page
    function goToNextPage() {
        const predictionData = localStorage.getItem("prediction");
        const predictions = JSON.parse(predictionData);
        const bestPrediction = getHighestConfidencePrediction(predictions);

        // Lower case the name to match the expected URL parameter
        bestPrediction.name = bestPrediction.name.toLowerCase();

        // Pass the prediction name as URL parameter
        if(bestPrediction.name == "glass" || bestPrediction.name == "metal"){
            window.location.href = `trash-guide.html?type=metalOrGlass`;
        } else {
            window.location.href = `trash-guide.html?type=${bestPrediction.name}`;
        }
    }

    // Improved resize handler with debouncing
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const resultImage = document.getElementById('resultImage');
            const boundingBoxesContainer = document.getElementById('boundingBoxes');
            const predictionData = localStorage.getItem("prediction");

            if (resultImage && boundingBoxesContainer && predictionData && resultImage.complete) {
                const predictions = JSON.parse(predictionData);
                drawBoundingBox(resultImage, boundingBoxesContainer, predictions);
            }
        }, 250);
    });

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', loadResults);
</script>

</html>