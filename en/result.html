<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <script src="../script.js"></script>
    <title>NeuroSort</title>
    <style>
        /* Ensure proper positioning context */
        .image-wrapper {
            position: relative;
            display: inline-block;
        }
        .bounding-boxes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .result-image {
            display: block;
            max-width: 100%;
            height: auto;
        }
        .bounding-box {
            position: absolute;
            border: 2px solid;
            border-radius: 4px;
            pointer-events: none;
            box-sizing: border-box;
        }
        .box-label {
            position: absolute;
            padding: 4px 8px;
            border-radius: 4px;
            fontSize: 12px;
            font-weight: bold;
            color: white;
            white-space: nowrap;
            border: 1px solid;
        }
        .recyclable-label {
            position: absolute;
            padding: 2px 6px;
            background-color: #28a745;
            color: white;
            font-size: 10px;
            border-radius: 3px;
            font-weight: bold;
            white-space: nowrap;
        }
        /* Debug styles */
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            max-width: 300px;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <div id="error" class="error" style="display: none;">
        <h2>Error</h2>
        <p>No detection data found. Please go back and scan an image.</p>
        <button class="error-button" onclick="goBack()">Go Back</button>
    </div>

    <div id="result" style="display: none;">
        <div class="result-wrapper">
            <div class="background-layer">
                <img id="backgroundImage" class="background-image" alt="">
            </div>

            <div class="result-container">
                <div class="image-wrapper">
                    <img id="resultImage" class="result-image" alt="Detection Result">
                    <div id="boundingBoxes" class="bounding-boxes"></div>
                </div>
            </div>
            <button class="next-button" onclick="goToNextPage()">Next</button>
        </div>
        
        <!-- Debug panel -->
        <div id="debugInfo" class="debug-info" style="display: none;"></div>
        <button onclick="toggleDebug()" style="position: fixed; top: 10px; left: 10px; z-index: 1001;">Toggle Debug</button>
    </div>
</body>
<script>
    // Define everything at the top
    const DETECTION_COLORS = {
        'paper': '#237db2',
        'plastic': '#e4861b',
        'metal': '#99612d',
        'glass': '#99612d'
    };

    let debugMode = false;

    function toggleDebug() {
        debugMode = !debugMode;
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.style.display = debugMode ? 'block' : 'none';
    }

    function updateDebugInfo(info) {
        if (!debugMode) return;
        const debugDiv = document.getElementById('debugInfo');
        debugDiv.innerHTML = `
            <strong>Debug Info:</strong><br>
            Natural: ${info.naturalWidth}x${info.naturalHeight}<br>
            Displayed: ${Math.round(info.displayWidth)}x${Math.round(info.displayHeight)}<br>
            Scale: ${info.scaleX.toFixed(3)}x${info.scaleY.toFixed(3)}<br>
            Image Pos: ${Math.round(info.imageLeft)}, ${Math.round(info.imageTop)}<br>
            Container: ${Math.round(info.containerWidth)}x${Math.round(info.containerHeight)}<br>
            Original Box: (${info.box.x1}, ${info.box.y1}) to (${info.box.x2}, ${info.box.y2})<br>
            Scaled Box: (${Math.round(info.scaledX1)}, ${Math.round(info.scaledY1)}) to (${Math.round(info.scaledX2)}, ${Math.round(info.scaledY2)})<br>
            Box Size: ${Math.round(info.boxWidth)}x${Math.round(info.boxHeight)}<br>
            Prediction: ${info.prediction.name} (${Math.round(info.prediction.confidence * 100)}%)
        `;
    }

    // Function to get color based on detection name
    function getDetectionColor(prediction) {
        const name = prediction.name.toLowerCase();
        return DETECTION_COLORS[name] || '#00ff00';
    }

    // Function to get the prediction with the highest confidence
    function getHighestConfidencePrediction(predictions) {
        if (!predictions || predictions.length === 0) return null;
        const sortedPredictions = predictions.sort((a, b) => b.confidence - a.confidence);
        return sortedPredictions[0];
    }

    // Load image and predictions from storage
    function loadResults() {
        try {
            const imageData = sessionStorage.getItem("uploadedImage");
            const predictionData = localStorage.getItem("prediction");

            if (!imageData || !predictionData) {
                showError();
                return;
            }

            const predictions = JSON.parse(predictionData);
            console.log("Loaded predictions:", predictions);
            setupImageAndDetections(imageData, predictions);

        } catch (error) {
            console.error("Error loading results:", error);
            showError();
        }
    }

    // Setup image and draw bounding boxes
    function setupImageAndDetections(imageData, predictions) {
        const resultImage = document.getElementById('resultImage');
        const backgroundImage = document.getElementById('backgroundImage');
        const boundingBoxesContainer = document.getElementById('boundingBoxes');

        backgroundImage.src = imageData;

        resultImage.onload = function () {
            console.log("Main image loaded");
            document.getElementById('result').style.display = 'block';

            // Multiple attempts to ensure proper rendering
            const attemptDraw = () => {
                if (resultImage.naturalWidth > 0 && resultImage.naturalHeight > 0) {
                    drawBoundingBox(resultImage, boundingBoxesContainer, predictions);
                } else {
                    setTimeout(attemptDraw, 50);
                }
            };

            // Try immediately and with delays
            attemptDraw();
            setTimeout(() => attemptDraw(), 100);
            setTimeout(() => attemptDraw(), 500);
        };

        resultImage.onerror = function () {
            console.error("Failed to load main image");
            showError();
        };

        resultImage.src = imageData;
    }

    // More robust bounding box drawing function
    function drawBoundingBox(imageElement, container, predictions) {
        container.innerHTML = '';

        const bestPrediction = getHighestConfidencePrediction(predictions);
        if (!bestPrediction || !bestPrediction.box) {
            console.log("No valid predictions or bounding box found");
            return;
        }

        // Wait for image to be fully rendered
        if (imageElement.naturalWidth === 0 || imageElement.naturalHeight === 0) {
            console.log("Image not ready, retrying...");
            setTimeout(() => drawBoundingBox(imageElement, container, predictions), 100);
            return;
        }

        // Get the image wrapper (parent container)
        const imageWrapper = imageElement.parentElement;
        const wrapperRect = imageWrapper.getBoundingClientRect();
        const imageRect = imageElement.getBoundingClientRect();
        
        // Calculate image position relative to its wrapper
        const imageLeft = imageRect.left - wrapperRect.left;
        const imageTop = imageRect.top - wrapperRect.top;
        
        const naturalWidth = imageElement.naturalWidth;
        const naturalHeight = imageElement.naturalHeight;
        const displayWidth = imageRect.width;
        const displayHeight = imageRect.height;

        // Calculate scaling factors
        const scaleX = displayWidth / naturalWidth;
        const scaleY = displayHeight / naturalHeight;

        const box = bestPrediction.box;
        
        // Apply scaling to box coordinates
        const scaledX1 = box.x1 * scaleX;
        const scaledY1 = box.y1 * scaleY;
        const scaledX2 = box.x2 * scaleX;
        const scaledY2 = box.y2 * scaleY;

        const boxWidth = scaledX2 - scaledX1;
        const boxHeight = scaledY2 - scaledY1;

        // Update debug info
        updateDebugInfo({
            naturalWidth, naturalHeight, displayWidth, displayHeight,
            scaleX, scaleY, imageLeft, imageTop,
            containerWidth: wrapperRect.width, containerHeight: wrapperRect.height,
            box, scaledX1, scaledY1, scaledX2, scaledY2,
            boxWidth, boxHeight, prediction: bestPrediction
        });

        // Additional debug logs to understand coordinate system
        console.log("=== COORDINATE ANALYSIS ===");
        console.log("Box coordinates as percentage of image:");
        console.log(`X1: ${(box.x1 / naturalWidth * 100).toFixed(2)}%`);
        console.log(`Y1: ${(box.y1 / naturalHeight * 100).toFixed(2)}%`);
        console.log(`X2: ${(box.x2 / naturalWidth * 100).toFixed(2)}%`);
        console.log(`Y2: ${(box.y2 / naturalHeight * 100).toFixed(2)}%`);
        console.log("If percentages > 100%, coordinates are likely in wrong format");

        // Validate dimensions
        if (boxWidth <= 0 || boxHeight <= 0) {
            console.warn("Invalid box dimensions:", { boxWidth, boxHeight });
            return;
        }

        // Create bounding box element
        const boundingBox = document.createElement('div');
        boundingBox.className = 'bounding-box';

        const color = getDetectionColor(bestPrediction);
        boundingBox.style.borderColor = color;
        boundingBox.style.backgroundColor = color + '26';
        boundingBox.style.boxShadow = `0 0 15px ${color}99`;

        // Position the box relative to the image position within the container
        boundingBox.style.left = (imageLeft + scaledX1) + 'px';
        boundingBox.style.top = (imageTop + scaledY1) + 'px';
        boundingBox.style.width = boxWidth + 'px';
        boundingBox.style.height = boxHeight + 'px';

        // Create main label
        const label = document.createElement('div');
        label.className = 'box-label';
        label.style.backgroundColor = color + 'F2';
        label.style.borderColor = color;

        const confidence = Math.round(bestPrediction.confidence * 100);
        label.textContent = `${bestPrediction.name} (${confidence}%)`;

        // Position label
        if (scaledY1 > 40) {
            label.style.top = '-35px';
            label.style.left = '0px';
        } else {
            label.style.top = (boxHeight + 5) + 'px';
            label.style.left = '0px';
        }

        // Create recyclable label
        const recyclableLabel = document.createElement('div');
        recyclableLabel.className = 'recyclable-label';
        recyclableLabel.textContent = 'Recyclable';

        if (scaledY1 > 40) {
            recyclableLabel.style.top = '-15px';
            recyclableLabel.style.left = '0px';
        } else {
            recyclableLabel.style.top = (boxHeight + 25) + 'px';
            recyclableLabel.style.left = '0px';
        }

        boundingBox.appendChild(label);
        boundingBox.appendChild(recyclableLabel);
        container.appendChild(boundingBox);

        console.log("Bounding box positioned:", {
            imagePosition: { left: imageLeft, top: imageTop },
            boxPosition: { 
                left: imageLeft + scaledX1, 
                top: imageTop + scaledY1,
                width: boxWidth,
                height: boxHeight
            },
            originalBox: box,
            scale: { x: scaleX, y: scaleY }
        });
    }

    // Show error message
    function showError() {
        document.getElementById('error').style.display = 'flex';
    }

    // Navigation functions
    function goBack() {
        window.history.back();
    }

    function goToNextPage() {
        const predictionData = localStorage.getItem("prediction");
        const predictions = JSON.parse(predictionData);
        const bestPrediction = getHighestConfidencePrediction(predictions);

        bestPrediction.name = bestPrediction.name.toLowerCase();

        if(bestPrediction.name == "glass" || bestPrediction.name == "metal"){
            window.location.href = `trash-guide.html?type=metalOrGlass`;
        } else {
            window.location.href = `trash-guide.html?type=${bestPrediction.name}`;
        }
    }

    // Enhanced resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const resultImage = document.getElementById('resultImage');
            const boundingBoxesContainer = document.getElementById('boundingBoxes');
            const predictionData = localStorage.getItem("prediction");

            if (resultImage && boundingBoxesContainer && predictionData && resultImage.complete) {
                const predictions = JSON.parse(predictionData);
                drawBoundingBox(resultImage, boundingBoxesContainer, predictions);
            }
        }, 100);
    });

    document.addEventListener('DOMContentLoaded', loadResults);
</script>

</html>